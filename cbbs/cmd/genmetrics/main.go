package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	cbvalue "github.com/couchbase/tools-common/couchbase/v2/value"
	"github.com/couchbase/tools-common/errors/definitions"
	fsutil "github.com/couchbase/tools-common/fs/util"
)

// MetricType denotes the type of a metric we expose.
type MetricType string

const (
	MetricTypeCounter   MetricType = "counter"
	MetricTypeGauge     MetricType = "gauge"
	MetricTypeHistogram MetricType = "histogram"
)

func (m MetricType) Validate() error {
	switch m {
	case MetricTypeCounter, MetricTypeGauge, MetricTypeHistogram:
		return nil
	default:
		return fmt.Errorf("unknown type: %s", m)
	}
}

// Stability is how stable a metric is.
type Stability string

const (
	// StabilityCommitted means the metric will retain semantics across server versions and only be removed once it has
	// been deprecated for some time.
	StabilityCommitted Stability = "committed"

	// StabilityVolatile means the metric can be changed at any time.
	StabilityVolatile Stability = "volatile"

	// StabilityInternal means the metric will not be shown in our user-facing documentation.
	StabilityInternal Stability = "internal"
)

func (s Stability) Validate() error {
	switch s {
	case StabilityCommitted, StabilityVolatile, StabilityInternal:
		return nil
	// Empty stability is valid
	case "":
		return nil
	default:
		return fmt.Errorf("unknown stability: %s", s)
	}
}

// MetricsInfo is a map of metric names to their metadata.
type MetricsInfo map[string]MetricInfo

// MetricInfo contains information about metrics that is used to generate code for them and their documentation.
type MetricInfo struct {
	// Help is a short sentence to describe what the metric shows.
	//
	// NOTE: Required
	Help string `json:"help"`

	// Type is the Prometheus metric type.
	//
	// NOTE: Required
	Type MetricType `json:"type"`

	// Labels are used to categorise metrics.
	//
	// NOTE: Required (can be empty)
	Labels []string `json:"labels"`

	// Added is the Couchbase Server version that the metric was introduced.
	//
	// NOTE: Required
	Added cbvalue.Version `json:"added"`

	// Stability is the stability of the metric.
	Stability Stability `json:"stability,omitempty"`

	// Notes can contain longer comments on the metric such as how it should be used, what insight it can give etc.
	Notes string `json:"notes,omitempty"`

	// HistogramBuckets is a list of buckets to put the data in for a histogram.
	//
	// NOTE: Required if 'Type' is 'histogram'.
	HistogramBuckets []float64 `json:"histogram_buckets,omitempty"`

	// Deprecated is the Couchbase Server version that the metric was deprecated in. If this field is set then Notes
	// should include a description of how clients can move away from using this metric.
	Deprecated cbvalue.Version `json:"deprecated,omitempty"`

	// Unit is the unit of the metric (e.g. bytes).
	Unit string `json:"unit,omitempty"`
}

func (m *MetricInfo) Validate() error {
	var me definitions.MultiError

	if m.Help == "" {
		me.Add(fmt.Errorf("metric help is required"))
	}

	if m.Added == "" {
		me.Add(fmt.Errorf("metric added version is required"))
	}

	if err := m.Stability.Validate(); err != nil {
		me.Add(err)
	}

	if err := m.Type.Validate(); err != nil {
		me.Add(err)
	}

	if m.Type == MetricTypeHistogram && len(m.HistogramBuckets) == 0 {
		me.Add(fmt.Errorf("histogram buckets are required for histogram metrics"))
	}

	return me.ErrOrNil()
}

// snakeToCamelCase converts the string s to camel case.
func snakeToCamelCase(s string) string {
	var (
		runes = []rune(s)
		res   = ""
	)

	for i := 0; i < len(runes); i++ {
		r := runes[i]

		if r == '_' && i != len(runes)-1 {
			res += strings.ToUpper(string([]rune{runes[i+1]}))
			i++

			continue
		}

		res += string([]rune{r})
	}

	return res
}

var templates = map[string]string{
	"file": `// Code generated by genmetrics. DO NOT EDIT.
package {{$.Package}}

import "github.com/prometheus/client_golang/prometheus"
`,

	"counter": `
var {{$.VariableName}} = prometheus.NewCounterVec(prometheus.CounterOpts{
	Name: "{{$.Name}}",
	Help: "{{$.Help}}",
}, {{$.Labels}})
`,
	"gauge": `
var {{$.VariableName}} = prometheus.NewGaugeVec(prometheus.GaugeOpts{
	Name: "{{$.Name}}",
	Help: "{{$.Help}}",
}, {{$.Labels}})
`,
	"histogram": `
var {{$.VariableName}} = prometheus.NewHistogramVec(prometheus.HistogramOpts{
	Name: "{{$.Name}}",
	Help: "{{$.Help}}",
	Buckets: {{$.HistogramBuckets}},
}, {{$.Labels}})
`,

	"labels":  `[]string{ {{range $i, $label := .Labels}}"{{$label}}", {{end}} }`,
	"buckets": `[]float64{ {{range $i, $bucket := .HistogramBuckets}}{{$bucket}}, {{end}} }`,
}

// metricItem is the data type used for templates to generate the metric code.
type metricItem struct {
	VariableName     string
	Name             string
	Help             string
	Labels           string
	HistogramBuckets string
}

func getTemplates() (map[string]*template.Template, error) {
	res := make(map[string]*template.Template)

	for k, v := range templates {
		tmpl := template.New(k)
		if _, err := tmpl.Parse(v); err != nil {
			return nil, fmt.Errorf("could not parse template %s: %w", k, err)
		}

		res[k] = tmpl
	}

	return res, nil
}

// generateCode generates Go code using the Prometheus library for the given metrics and writes it to the given file.
func generateCode(metrics MetricsInfo, codeOutputPath, pkg string) error {
	file, err := fsutil.CreateFile(codeOutputPath, os.O_WRONLY, 0o644)
	if err != nil {
		return fmt.Errorf("could not open file %s: %w", codeOutputPath, err)
	}
	defer file.Close()

	templates, err := getTemplates()
	if err != nil {
		return fmt.Errorf("could not get templates: %w", err)
	}

	if err := templates["file"].Execute(file, struct{ Package string }{Package: pkg}); err != nil {
		return fmt.Errorf("could not render template: %w", err)
	}

	for name, metric := range metrics {
		var tmpl *template.Template

		switch metric.Type {
		case MetricTypeCounter:
			tmpl = templates["counter"]
		case MetricTypeGauge:
			tmpl = templates["gauge"]
		case MetricTypeHistogram:
			tmpl = templates["histogram"]
		default:
			return fmt.Errorf("unknown metric type: %s", metric.Type)
		}

		var buckets, labels bytes.Buffer
		if err := templates["labels"].Execute(&labels, struct{ Labels []string }{Labels: metric.Labels}); err != nil {
			return fmt.Errorf("could not render labels template: %w", err)
		}

		if metric.Type == MetricTypeHistogram {
			type histogramData struct {
				HistogramBuckets []float64
			}

			var (
				bucketsTmpl = templates["buckets"]
				data        = histogramData{HistogramBuckets: metric.HistogramBuckets}
			)

			if err := bucketsTmpl.Execute(&buckets, data); err != nil {
				return fmt.Errorf("could not render buckets template: %w", err)
			}
		}

		err := tmpl.Execute(file, metricItem{
			VariableName:     snakeToCamelCase(name),
			Name:             name,
			Help:             metric.Help,
			Labels:           labels.String(),
			HistogramBuckets: buckets.String(),
		})
		if err != nil {
			return fmt.Errorf("could not render metric template: %w", err)
		}
	}

	return nil
}

// readMetrics reads metric info, in JSON, from the given file. Validates the info is correct and returns it.
func readMetrics(inputPath string) (MetricsInfo, error) {
	file, err := os.Open(inputPath)
	if err != nil {
		return nil, fmt.Errorf("could not open file %s: %w", inputPath, err)
	}
	defer file.Close()

	var metrics MetricsInfo
	if err := json.NewDecoder(file).Decode(&metrics); err != nil {
		return nil, fmt.Errorf("could not read metrics: %w", err)
	}

	for k, v := range metrics {
		if err := v.Validate(); err != nil {
			return nil, fmt.Errorf("metric %s is invalid: %w", k, err)
		}
	}

	return metrics, nil
}

// generateMetadata writes 'metrics' out to the given filepath in the format our documentation process expects, i.e.
// without the histogram buckets.
func generateMetadata(metrics MetricsInfo, metadataOutputPath string) error {
	file, err := fsutil.CreateFile(metadataOutputPath, os.O_WRONLY, 0o644)
	if err != nil {
		return fmt.Errorf("could not open file %s: %w", metadataOutputPath, err)
	}
	defer file.Close()

	metadata := make(map[string]MetricInfo, len(metrics))

	for k, v := range metrics {
		v.HistogramBuckets = nil
		metadata[k] = v
	}

	enc := json.NewEncoder(file)
	enc.SetIndent("", "  ")

	if err := enc.Encode(metadata); err != nil {
		return fmt.Errorf("could not write metrics: %w", err)
	}

	return nil
}

func main() {
	if len(os.Args) != 4 {
		fmt.Println("usage: genmetrics <input-file> <code-output-file> <metadata-json-output-file>")
		os.Exit(1)
	}

	var (
		inputFile          = os.Args[1]
		codeOutputFile     = os.Args[2]
		metadataOutputFile = os.Args[3]
		codePackage        = filepath.Base(filepath.Dir(codeOutputFile))
	)

	if codePackage == "." {
		dir, err := os.Getwd()
		if err != nil {
			fmt.Printf("could not get current working directory: %s\n", err)
			os.Exit(1)
		}

		codePackage = filepath.Base(dir)
	}

	metrics, err := readMetrics(inputFile)
	if err != nil {
		fmt.Printf("could not read metrics: %s\n", err)
		os.Exit(1)
	}

	if err := generateCode(metrics, codeOutputFile, codePackage); err != nil {
		fmt.Printf("could not generate code: %s\n", err)
		os.Exit(1)
	}

	if err := generateMetadata(metrics, metadataOutputFile); err != nil {
		fmt.Printf("could not generate metadata: %s\n", err)
		os.Exit(1)
	}
}
